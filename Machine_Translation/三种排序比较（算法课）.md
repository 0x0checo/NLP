好的，我们来仔细梳理一下这三种排序算法：**Insertion Sort（插入排序）**、**Selection Sort（选择排序）**和**Sink Sort（下沉排序）**。我会分别解释原理、步骤和特点，方便你理解它们的区别。

---

### 1️⃣ **Insertion Sort（插入排序）**

**原理：**
把数组分成已排序区和未排序区，每次从未排序区取一个元素，把它插入到已排序区的正确位置，使已排序区始终有序。

**步骤：**

1. 从第二个元素开始（第一个元素默认为已排序区）。
2. 取当前元素，和已排序区从后向前比较。
3. 找到正确位置，将元素插入（可能需要移动已排序区的元素）。
4. 重复步骤 2-3，直到数组全部排序。

**例子：**

```text
初始数组: 5 2 4 6 1 3
第一步: 已排序 [5], 未排序 [2 4 6 1 3] → 插入2 → [2 5]
第二步: 已排序 [2 5], 未排序 [4 6 1 3] → 插入4 → [2 4 5]
...
```

**特点：**

* 时间复杂度：平均和最坏 O(n²)，最好 O(n)（已经有序）。
* 稳定排序（相同元素保持原顺序）。
* 适合小数组或几乎有序数组。

---

### 2️⃣ **Selection Sort（选择排序）**

**原理：**
每次从未排序区选出最小（或最大）元素，放到已排序区末尾，重复直到数组有序。

**步骤：**

1. 从整个数组中找到最小元素。
2. 与数组第一个位置交换。
3. 从剩余未排序区中继续找最小元素，放到下一个位置。
4. 重复直到数组全部排序。

**例子：**

```text
初始数组: 5 2 4 6 1 3
第一步: 找最小1 → 交换到第1位 → [1 2 4 6 5 3]
第二步: 找剩余区最小2 → 交换 → [1 2 4 6 5 3]
...
```

**特点：**

* 时间复杂度：O(n²)，不受数组初始顺序影响。
* 不稳定排序（可能打乱相同元素顺序）。
* 操作交换次数少（最多 n 次）。

---

### 3️⃣ **Sink Sort（下沉排序）**

这个排序名字不常见，有时也称“泡沫下沉排序”或“Sink Sort”。**它是冒泡排序的一种变体**，思路是把较大（或较小）的元素不断“下沉”到数组末尾（或开头）。

**原理：**
从头到尾比较相邻元素，如果顺序错误就交换，把最大的元素“下沉”到数组末尾。重复操作直到数组有序。

**步骤：**

1. 比较数组中相邻元素，如果前一个比后一个大，交换它们。
2. 每一轮结束后，最大元素已经到最后。
3. 对剩余未排序区重复步骤1-2。
4. 直到整个数组排序完成。

**例子：**

```text
初始数组: 5 2 4 6 1 3
第一轮: 5>2 →交换 → 2 5 4 6 1 3
        5>4 →交换 → 2 4 5 6 1 3
        5<6 →不动
        6>1 →交换 → 2 4 5 1 6 3
        6>3 →交换 → 2 4 5 1 3 6
最大元素6下沉到末尾
下一轮对前5个元素重复...
```

**特点：**

* 时间复杂度：O(n²)
* 稳定排序
* 实质上类似**冒泡排序**，每轮“下沉”最大值。

---

### ✅ 总结比较表

| 排序算法 | 核心思路           | 时间复杂度   | 稳定性 | 适用场景       |
| ---- | -------------- | ------- | --- | ---------- |
| 插入排序 | 每次插入未排序元素到已排序区 | 最坏O(n²) | 稳定  | 小数组、近乎有序   |
| 选择排序 | 每次选择最小元素放到前面   | O(n²)   | 不稳定 | 数据量小、交换次数少 |
| 下沉排序 | 相邻元素比较，最大下沉到末尾 | O(n²)   | 稳定  | 理解冒泡排序思路   |

---

你想让我画吗？
